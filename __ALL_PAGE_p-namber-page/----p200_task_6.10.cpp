//	p200-208 6.10

#include <iostream>
#include <stdio.h> 
#include <stdlib.h> 
#include <math.h>
#include <time.h>

using namespace std ;

int SLAU(double ∗∗matrica_a , int n, double ∗massiv_b , double ∗x)
//Функция SLAU возвращает значение типа int: 0, если решение найдено, −1 — если система имеет //бесконечное множество решений, −2 — если система не имеет решений.
//Формальные параметры функции: n — размерность системы,
//matrica_a — матрица коэффициентов СЛАУ,
//massiv_b — вектор правых частей, x — решение СЛАУ, передаются как указатели.
{
int i,j,k,r;
double c,M,max,s;
//Матрица a — копия матрицы коэффициентов, массив b — копия вектора правых частей. double ∗∗a, ∗b;
a=new double ∗ [ n ] ; //Выделение памяти для a и b.
		       //
		       //
f o r ( i = 0 ; i <n ; i ++) a[i]=new double[n];
b=new double [n];
//В a записываем копию матрицы коэффициентов, в b копию вектора правых частей. f o r ( i = 0 ; i <n ; i ++)
f o r ( j = 0 ; j <n ; j ++)
a[ i ][ j]=matrica_a[ i ][ j ]; f o r ( i = 0 ; i <n ; i ++)
b[ i]=massiv_b[ i ];
//Прямой ход метода Гаусса: приводим матрицу a (копию матрицы коэффициентов СЛАУ) //к диагональному виду.
for(k=0;k<n;k++)

{ //Поиск максимального по модулю элемента в k-м столбце. max=f a b s ( a [ k ] [ k ] ) ;
r=k;
f o r ( i =k + 1 ; i <n ; i ++)
if (fabs(a[i][k])>max) {
m a x= f a b s ( a [ i ] [ k ] ) ; r=i ;
}
for(j=0;j<n;j++) //Меняемместамиk-юиr-ю(строку,гденаходится { //максимальный по модулю элемент) строки.
c=a[k][ j ];
a [ k ] [ j ]=a [ r ] [ j ] ; a [ r ] [ j ]= c ;
}
c=b [ k ] ;
b [ k]=b [ r ] ;
b [ r ]= c ;
for(i=k+1;i<n;i++) //Приведениематрицыкдиагональномувиду. {
f o r ( M= a [ i ] [ k ] / a [ k ] [ k ] , j = k ; j < n ; j + + ) a [ i ] [ j ]−=M∗ a [ k ] [ j ] ;
b [ i ] − =M∗ b [ k ] ;
} }
//Обратный ход метода Гаусса.
i f ( a [ n − 1 ] [ n−1]==0) //Если последний диагональный элемент равен 0 и
i f ( b [ n−1]==0) //последний коэффициент вектора свободных членов равен 0, return −1; //то система имеет бесконечное множество решений
e l s e return −2; //последний коэффициент вектора свободных членов не равен 0, //система решений не имеет.
else //Последний диагональный элемент не равен 0, начинается обратный ход метода Гаусса. {
f o r ( i =n − 1 ; i > = 0 ; i −−) {
for(s=0,j=i+1;j<n; j++) s+=a [ i ] [ j ] ∗ x [ j ] ;
x[ i]=(b[ i]−s)/a[ i ][ i ]; }
return

int main(int argc, char * argv[])
{

int result ,i ,j ,N;
double ∗∗a, ∗b, ∗x;
cout<<"N=" ; //Ввод размерности системы.
cin>>N;
a=new double ∗ [N ] ; //Выделение памяти для матрицы правых частей и вектора свободных
членов.
f o r ( i = 0 ; i <N ; i + + )
a[i]=new double[N];
b=new double [N];
x=new double [N];
cout<<"Ввод матрицы A"<<endl ; //Ввод матрицы правых частей f o r ( i = 0 ; i <N ; i + + )
f o r ( j = 0 ; j <N ; j + + ) c i n >>a [ i ] [ j ] ;
cout<<"Ввод вектора B"<<endl ; //и вектора свободных членов. f o r ( i = 0 ; i <N ; i + + )
c i n >>b [ i ] ;
//Вызов функции решения СЛАУ методом Гаусса. По значению result можно судить, сколько //корней имеет система. Если result=0, то система имеет единственное решение, result= −1 — //система имеет бесконечное множество решений, result=−2 — система не имеет решений.
r e s u l t =SLAU ( a , N , b , x ) ;

if ( result==0)
{ //Вывод массива решения.
cout<<"Massiv X"<<endl; f o r ( i = 0 ; i <N ; i + + )
c o u t << x [ i ] < < " \ t " ; cout<<endl ;
}
else if ( result==−1)
cout<<"Бесконечное множество решений\n" ; else if ( result==−2)
cout<<"Нет решений\n" ;


return 0 ;
}
